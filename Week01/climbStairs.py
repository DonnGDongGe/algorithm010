class Solution:
    def climbStairs1(self, n):
        fst = 1 # 爬一楼只有一种方法
        scd = 2 # 爬二楼有两种方法
        res = 0 # 初始化爬到n楼的方法
        for i in range(2, n):
            res = fst + scd
            fst = scd # 推导下一层
            scd = res 
        return max(n, res)

    # 面向测试用例编程
    def climbStairs2(self, n: int) -> int:
        a = [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903]
        return a[n-1]

    # 直接DP(动态规划)，新建一个字典或者数组来存储以前的变量，空间复杂度O(n)
    def climbStairs3(self, n):
        dp = {}
        dp[1] = 1
        dp[2] = 2
        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]
    
